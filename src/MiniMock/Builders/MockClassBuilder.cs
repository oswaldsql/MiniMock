namespace MiniMock.Builders;

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;

public static class MockClassBuilder
{
    public static string Build(IEnumerable<ISymbol> typeSymbols, SourceProductionContext context)
    {
        var builder = new CodeBuilder();

        builder.Add($$"""
                     // Generated by MiniMock on {{DateTime.Now}}
                     #nullable enable
                     namespace MiniMock {
                     ->

                     /// <summary>
                     /// Factory for creating mock objects.
                     /// </summary>
                     internal static class Mock {
                     ->
                     """);

        foreach (var symbol in typeSymbols.OfType<INamedTypeSymbol>())
        {
            var typeArguments = symbol.TypeArguments;
            var containingNamespace = symbol.ContainingNamespace;
            var symbolName = symbol.Name;

            if (typeArguments.Length > 0)
            {
                var types = string.Join(", ", typeArguments.Select(t => t.Name));
                var name = $"{symbolName}Mock<{types}>";
                var methodName = symbolName;
                var constraints = typeArguments.ToConstraints();

                var cref = symbol.ToString().Replace('<','{').Replace('>','}');
                builder.Add(
                    $"""

                      /// <summary>
                      /// Creates a mock object for <see cref="{cref}"/>.
                      /// </summary>
                      /// <param name="config">Optional configuration for the mock object.</param>
                      /// <returns>The mock object for <see cref="{cref}"/>.</returns>
                      """);
                builder.Add($"internal static {symbol} {methodName}<{types}>(System.Action<{containingNamespace}.{name}.Config>? config = null) {constraints} => {containingNamespace}.{name}.Create(config);");
            }
            else
            {
                builder.Add(
                    $"""

                      /// <summary>
                      /// Creates a mock object for <see cref="{symbol}"/>.
                      /// </summary>
                      /// <param name="config">Optional configuration for the mock object.</param>
                      /// <returns>The mock object for <see cref="{symbol}"/>.</returns>
                      """);
                var name = symbolName + "Mock";
                var methodName = symbolName;
                builder.Add($"internal static {symbol} {methodName}(System.Action<{containingNamespace}.{name}.Config>? config = null) => {containingNamespace}.{name}.Create(config);");
            }
        }

        builder.Add("""
                   <-
                   }
                   <-
                   }
                   """);

        return builder.ToString();
    }

    //private static string Constraints(ImmutableArray<ITypeSymbol> typeArguments)
    //{
    //    var result = new StringBuilder();
    //
    //    foreach (var s in typeArguments.Select(type => BuildConstraintsString((ITypeParameterSymbol)type)))
    //    {
    //        result.Append(s);
    //    }
    //
    //    return result.ToString().Trim();
    //}
    //
    //private static string BuildConstraintsString(ITypeParameterSymbol symbol)
    //{
    //    var result = new List<string>();
    //
    //    foreach (var t in symbol.ConstraintTypes)
    //    {
    //        result.Add(t.ToString());
    //    }
    //
    //    if (symbol.HasUnmanagedTypeConstraint)
    //    {
    //        result.Add("unmanaged");
    //    }
    //    else
    //    {
    //        if (symbol.HasConstructorConstraint) result.Add("new()");
    //        if(symbol.HasValueTypeConstraint) result.Add("struct");
    //    }
    //
    //    if(symbol.HasReferenceTypeConstraint) result.Add("class");
    //    if(symbol.HasNotNullConstraint) result.Add("notnull");
    //
    //    if (result.Count == 0) { return "";}
    //
    //    return " where " + symbol.Name + " : " + string.Join(", ", result);
    //}
}
