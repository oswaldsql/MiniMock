namespace MiniMock.Builders;

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;

internal class ClassBuilder(ISymbol target)
{
    public static string Build(ISymbol symbol) =>
        new ClassBuilder(symbol).BuildClass();

    private string BuildClass()
    {
        if (target.IsSealed && target is INamedTypeSymbol symbol)
        {
            throw new CanNotMockASealedClassException(symbol);
        }

        var builder = new CodeBuilder();

        var fullName = target.ToString();
        var interfaceNamespace = target.ContainingNamespace;
        var name = "MockOf_" + target.Name;

        var constraints = "";

        var typeArguments = ((INamedTypeSymbol)target).TypeArguments;
        if (typeArguments.Length > 0)
        {
            constraints = typeArguments.ToConstraints();
            var types = string.Join(", ", typeArguments.Select(t => t.Name));
            name = $"MockOf_{target.Name}<{types}>";
        }

        var documentationName = fullName.Replace("<", "{").Replace(">", "}");

        builder.Add($$"""
                      // Generated by MiniMock on {{DateTime.Now}}
                      #nullable enable
                      namespace {{interfaceNamespace}}
                      {
                      ->
                      /// <summary>
                      /// Mock implementation of <see cref="{{documentationName}}"/>. Should only be used for testing purposes.
                      /// </summary>
                      internal class {{name}} : {{fullName}} {{constraints}}
                      {
                      ->
                      private Config _config { get; }
                      internal void GetConfig(out Config config) => config = _config;

                      internal partial class Config
                      {
                          private readonly {{name}} target;

                          public Config({{name}} target)
                          {
                              this.target = target;
                          }
                      }
                      """);

        this.BuildConstructor(builder, fullName, name);

        this.BuildMembers(builder);

        builder.Add("""
                    <-
                    }
                    <-
                    }
                    """);

        return builder.ToString();
    }

    private void BuildConstructor(CodeBuilder builder, string fullName, string name)
    {
        var symbol = (INamedTypeSymbol)target;

        var constructors = symbol.Constructors
            .Where(c => this.accessibilityFilter(c.DeclaredAccessibility))
            .ToArray();

        builder.Add("#region constructors");

        if (constructors.Length == 0 || constructors.Any(t => t.Parameters.Length == 0))
        {
            builder.Add($$"""
                          internal protected MockOf_{{target.Name}}(System.Action<Config>? config = null) {
                              var result = new Config(this);
                              config = config ?? new System.Action<Config>(t => { });
                              config.Invoke(result);
                              _config = result;
                          }

                          public static {{fullName}} Create(System.Action<Config>? config = null) => new {{name}}(config);
                          """);
        }

        foreach (var constructor in constructors.Where(t => t.Parameters.Length > 0))
        {
            var parameters = constructor.Parameters.Select(p => $"{p.Type} {p.Name}").ToArray();
            var parameterList = string.Join(", ", parameters);
            var parameterNames = constructor.Parameters.Select(p => p.Name).ToArray();
            var parameterNamesList = string.Join(", ", parameterNames);

            builder.Add($$"""
                          internal protected MockOf_{{target.Name}}({{parameterList}}, System.Action<Config>? config = null) : base({{parameterNamesList}}) {
                              var result = new Config(this);
                              config = config ?? new System.Action<Config>(t => { });
                              config.Invoke(result);
                              _config = result;
                          }

                          public static {{fullName}} Create({{parameterList}}, System.Action<Config>? config = null) => new {{name}}({{parameterNamesList}}, config);
                          """);
        }

        builder.Add("#endregion");

    }

    private readonly Func<Accessibility, bool> accessibilityFilter = accessibility => accessibility == Accessibility.Public || accessibility == Accessibility.Protected;

    private void BuildMembers(CodeBuilder builder)
    {
        var memberCandidates = new List<ISymbol>(((INamedTypeSymbol)target).GetMembers().Where(t => this.accessibilityFilter(t.DeclaredAccessibility)));

        if (((INamedTypeSymbol)target).TypeKind == TypeKind.Interface)
        {
            this.AddInheritedInterfaces(memberCandidates, (INamedTypeSymbol)target);
        }

        var memberGroups = memberCandidates.Distinct(SymbolEqualityComparer.IncludeNullability).ToLookup(t => t.Name);

        foreach (var members in memberGroups)
        {
            var symbol = members.First();
            switch (symbol)
            {
                case IEventSymbol:
                    EventBuilder.BuildEvents(builder, members.OfType<IEventSymbol>());
                    break;
                case IMethodSymbol { MethodKind: MethodKind.Ordinary }:
                    MethodBuilder.BuildMethods(builder, members.OfType<IMethodSymbol>());
                    break;
                case IPropertySymbol { IsIndexer: false }:
                    PropertyBuilder.BuildProperties(builder, members.OfType<IPropertySymbol>());
                    break;
                case IPropertySymbol { IsIndexer: true }:
                    IndexBuilder.BuildIndexes(builder, members.OfType<IPropertySymbol>());
                    break;
            }
        }
    }

    private void AddInheritedInterfaces(List<ISymbol> memberCandidates, INamedTypeSymbol namedTypeSymbol)
    {
        var allInterfaces = namedTypeSymbol.AllInterfaces;
        foreach (var interface2 in allInterfaces)
        {
            memberCandidates.AddRange(interface2.GetMembers());
            this.AddInheritedInterfaces(memberCandidates, interface2);
        }
    }
}
